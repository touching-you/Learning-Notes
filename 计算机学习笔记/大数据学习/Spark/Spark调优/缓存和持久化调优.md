1. 缓存级别选择

   > 1. **MEMORY_ONLY**：将数据缓存在内存中，这是最常见的缓存级别。如果数据集可以适合在内存中缓存，那么将数据缓存在内存中通常可以获得最佳的性能提升。
   >
   > 2. **MEMORY_ONLY_SER**：将数据序列化后缓存在内存中。相比于 MEMORY_ONLY 级别，MEMORY_ONLY_SER 级别可以节省内存空间，并且可以提高缓存数据的读取速度。
   >
   > 3. **MEMORY_AND_DISK**：将数据缓存在内存和磁盘的组合中，如果内存不足时可以使用磁盘上的数据。这个级别可以提供更大的缓存容量，但是读取速度相对较慢。
   >
   > 4. **MEMORY_AND_DISK_SER**：将数据序列化后缓存在内存和磁盘的组合中，相比于 MEMORY_AND_DISK 级别可以节省内存空间。
   >
   > 5. **DISK_ONLY**：将数据缓存在磁盘上，这个级别通常用于大型数据集，因为无法全部缓存在内存中。
   >
   >    ***序列化即将对象转换成字节流形式存储，这样能更快进行网络传输或数据读写**。*

2. 持久化级别选择

   > 数据持久化和数据缓存选项相同，而在选择上，持久化一般优先选择磁盘，因为内存容量一般较小，往往用于cpu计算和缓存，在内存上持久化往往会影响cpu运行。

3. 序列化选择

> 在 Spark 中，数据序列化是将数据对象转换为字节流的过程，以便于在网络上传输或持久化到磁盘或内存中。选择合适的序列化形式可以提高 Spark 应用程序的性能和资源利用率。
>
> 在 Spark 中，支持多种序列化形式，包括 Java 默认的序列化方式和 Spark 内置的 Kryo 序列化方式。相比于 Java 默认的序列化方式，Kryo 序列化方式可以提供更快的序列化速度和更小的序列化后的数据大小。
>
> 选择序列化形式需要综合考虑以下几个方面：
>
> 1. **序列化速度**：序列化速度是指将数据对象转换为字节流的速度，选择快速的序列化方式可以提高 Spark 应用程序的性能。Kryo 序列化方式通常比 Java 默认的序列化方式快。
> 2. **序列化后数据大小**：序列化后的数据大小直接影响缓存和网络传输时所占用的内存大小，选择较小的序列化后数据大小可以提高资源利用率。Kryo 序列化方式通常比 Java 默认的序列化方式产生更小的序列化后数据大小。
> 3. **序列化兼容性**：序列化兼容性是指在序列化过程中对对象的修改是否会影响反序列化后的对象。Java 默认的序列化方式存在一些兼容性问题，而 Kryo 序列化方式支持更好的兼容性。
>
> 综上所述，选择合适的序列化形式可以提高 Spark 应用程序的性能和资源利用率。**如果应用程序中存在大量的序列化和反序列化操作，可以选择 Kryo 序列化方式。如果应用程序中需要支持较高的序列化兼容性，可以选择 Java 默认的序列化方式。**可以根据具体的应用场景和需求选择合适的序列化形式。